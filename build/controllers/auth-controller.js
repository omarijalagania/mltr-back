"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.userRegister=exports.userLogin=exports.userBuyPro=exports.updateUser=exports.tokenVerify=exports.testFunc=exports.registerWithGoogle=exports.registerWithApple=exports.loginWithGoogle=exports.loginWithApple=exports.getUserDetailsAdmin=exports.getUserDetails=exports.getUser=exports.getConfirmationCode=exports.getAllUsers=exports.deactivateAccount=exports.confirmDeactivationCode=exports.bulkEmailSend=exports.adminUserUpdate=void 0;var _models=require("../models");var _helpers=require("../helpers");var _mail=require("../mail");var _mongodb=require("mongodb");var _bcryptjs=_interopRequireDefault(require("bcryptjs"));var _jsonwebtoken=_interopRequireDefault(require("jsonwebtoken"));var _welcomeMltr=require("../mail/welcome-mltr");var _proMltr=require("../mail/pro-mltr");var _bull=_interopRequireDefault(require("bull"));var _templateTest=require("../mail/template-test");var _mailBulk=require("../mail/mail-bulk");var _joi=_interopRequireDefault(require("joi"));var _templateDefault=require("../mail/templateDefault");function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}const isValidEmail=_joi.default.string().email().required();const registerWithGoogle=async(req,res)=>{const{login,username,sex,birth,height,is_ft_heigth,body_type,physical_activities,weight,is_ft_weight,protein,calories,carbs,fat,customGoal,water,ip,device,geo,personal_goal}=req.body;try{if(isValidEmail.validate(login).error){return res.status(422).json({message:"Invalid email"})}let user=await _models.User.findOne({email:login});if(user){var _user,_user2,_user3;user=await _models.User.findOneAndUpdate({email:login},{email:login,username,sex,birth,height,is_ft_heigth,body_type,physical_activities,weight,is_ft_weight,protein,calories,carbs,fat,customGoal,water,geo,personal_goal},{new:true});const token=_jsonwebtoken.default.sign({_id:(_user=user)===null||_user===void 0?void 0:_user._id,name:(_user2=user)===null||_user2===void 0?void 0:_user2.email,isAdmin:(_user3=user)===null||_user3===void 0?void 0:_user3.isAdmin},process.env.JWT_SECRET);return res.status(201).json({message:"User updated and logged in",token})}else{var _user4,_user5,_user6;// Create new user
user=await _models.User.create({email:login,username,sex,birth,height,is_ft_heigth,body_type,physical_activities,weight,is_ft_weight,protein,calories,carbs,fat,customGoal,water,geo});const token=_jsonwebtoken.default.sign({_id:(_user4=user)===null||_user4===void 0?void 0:_user4._id,name:(_user5=user)===null||_user5===void 0?void 0:_user5.email,isAdmin:(_user6=user)===null||_user6===void 0?void 0:_user6.isAdmin},process.env.JWT_SECRET);(0,_mail.sendCodeConfirmation)("49640",login,_welcomeMltr.welcomeToMLTRTemplate,ip,device,"Welcome to MLTR");return res.status(201).json({message:"User Registered and logged in",token,_id:user._id,email:user.email,username:user.username,sex:user.sex,birth:user.birth,height:user.height,is_ft_heigth:user.is_ft_heigth,body_type:user.body_type,physical_activities:user.physical_activities,weight:user.weight,is_ft_weight:user.is_ft_weight,protein:user.protein,calories:user.calories,carbs:user.carbs,fat:user.fat,customGoal:user.customGoal,water:user.water,geo:user.geo,personal_goal:user.personal_goal})}}catch(error){res.status(500).json({message:"Something went wrong..."})}};exports.registerWithGoogle=registerWithGoogle;const loginWithGoogle=async(req,res)=>{const{login}=req.body;try{if(isValidEmail.validate(login).error){return res.status(422).json({message:"Invalid email"})}let user=await _models.User.findOne({email:login});if(!user){return res.status(404).json({message:"User not found"})}const token=_jsonwebtoken.default.sign({_id:user===null||user===void 0?void 0:user._id,name:user===null||user===void 0?void 0:user.email,isAdmin:user===null||user===void 0?void 0:user.isAdmin},process.env.JWT_SECRET);// Update the lastLogin time
user.lastLogin=new Date;user.status="active";await user.save();return res.status(200).json({message:"User logged in",token,_id:user._id,email:user.email,username:user.username,sex:user.sex,birth:user.birth,height:user.height,is_ft_heigth:user.is_ft_heigth,body_type:user.body_type,physical_activities:user.physical_activities,weight:user.weight,is_ft_weight:user.is_ft_weight,protein:user.protein,calories:user.calories,carbs:user.carbs,fat:user.fat,customGoal:user.customGoal,water:user.water,geo:user.geo,personal_goal:user.personal_goal})}catch(error){res.status(500).json({message:"Something went wrong..."})}};exports.loginWithGoogle=loginWithGoogle;const registerWithApple=async(req,res)=>{const{login,appleToken,username,sex,birth,height,is_ft_heigth,body_type,physical_activities,weight,is_ft_weight,protein,calories,carbs,fat,customGoal,water,ip,device,geo,personal_goal}=req.body;try{if(isValidEmail.validate(login).error){return res.status(422).json({message:"Invalid email"})}let user=await _models.User.findOne({email:login});if(user){var _user7,_user8,_user9,_user10;// User already exists, update user with new data
user=await _models.User.findOneAndUpdate({email:login},{email:login,appleToken,username,sex,birth,height,is_ft_heigth,body_type,physical_activities,weight,is_ft_weight,protein,calories,carbs,fat,customGoal,water,geo,personal_goal},{new:true});const token=_jsonwebtoken.default.sign({_id:(_user7=user)===null||_user7===void 0?void 0:_user7._id,name:(_user8=user)===null||_user8===void 0?void 0:_user8.email,appleToken:(_user9=user)===null||_user9===void 0?void 0:_user9.appleToken,isAdmin:(_user10=user)===null||_user10===void 0?void 0:_user10.isAdmin},process.env.JWT_SECRET);return res.status(201).json({message:"User Updated and logged in",token})}else{var _user11,_user12,_user13,_user14;// Create new user
user=await _models.User.create({email:login,appleToken,username,sex,birth,height,is_ft_heigth,body_type,physical_activities,weight,is_ft_weight,protein,calories,carbs,fat,customGoal,water,geo,personal_goal});const token=_jsonwebtoken.default.sign({_id:(_user11=user)===null||_user11===void 0?void 0:_user11._id,name:(_user12=user)===null||_user12===void 0?void 0:_user12.email,appleToken:(_user13=user)===null||_user13===void 0?void 0:_user13.appleToken,isAdmin:(_user14=user)===null||_user14===void 0?void 0:_user14.isAdmin},process.env.JWT_SECRET);(0,_mail.sendCodeConfirmation)("49640",login,_welcomeMltr.welcomeToMLTRTemplate,ip,device,"Welcome to MLTR");return res.status(201).json({message:"User Registered and logged in",token,_id:user._id,email:user.email,username:user.username,sex:user.sex,birth:user.birth,height:user.height,is_ft_heigth:user.is_ft_heigth,body_type:user.body_type,physical_activities:user.physical_activities,weight:user.weight,is_ft_weight:user.is_ft_weight,protein:user.protein,calories:user.calories,carbs:user.carbs,fat:user.fat,customGoal:user.customGoal,water:user.water,geo:user.geo,personal_goal:user.personal_goal})}}catch(error){res.status(500).json({message:"Something went wrong..."})}};exports.registerWithApple=registerWithApple;const loginWithApple=async(req,res)=>{const{login}=req.body;try{if(isValidEmail.validate(login).error){return res.status(422).json({message:"Invalid email"})}let user=await _models.User.findOne({email:login});if(user){const token=_jsonwebtoken.default.sign({_id:user===null||user===void 0?void 0:user._id,name:user===null||user===void 0?void 0:user.email,appleToken:user===null||user===void 0?void 0:user.appleToken,isAdmin:user===null||user===void 0?void 0:user.isAdmin},process.env.JWT_SECRET);// Update the lastLogin time
user.lastLogin=new Date;user.status="active";await user.save();return res.status(201).json({message:"User logged in",token,_id:user._id,email:user.email,username:user.username,sex:user.sex,birth:user.birth,height:user.height,is_ft_heigth:user.is_ft_heigth,body_type:user.body_type,physical_activities:user.physical_activities,weight:user.weight,is_ft_weight:user.is_ft_weight,protein:user.protein,calories:user.calories,carbs:user.carbs,fat:user.fat,customGoal:user.customGoal,water:user.water,geo:user.geo,personal_goal:user.personal_goal})}if(!user){res.status(404).json({message:"User not found"})}}catch(error){res.status(500).json({message:"Something went wrong..."})}};exports.loginWithApple=loginWithApple;const userRegister=async(req,res)=>{const{login,username,sex,birth,height,is_ft_heigth,body_type,physical_activities,weight,is_ft_weight,protein,calories,carbs,fat,customGoal,water,ip,device,geo,personal_goal}=req.body;try{if(isValidEmail.validate(login).error){return res.status(422).json({message:"Invalid email"})}let code=(0,_helpers.generateCode)();let user;user=await _models.User.findOne({email:login});/* Delete verification code, 1 hour after user registered or updated */setInterval(async()=>{// Execute the update operation
user=await _models.User.findOneAndUpdate({email:login},{code:""})},600000);/* Delete user after one day after inactive status */setInterval(async()=>{var query={status:{$eq:"inactive"}};user=await _models.User.deleteMany(query)},86400000);const salt=await _bcryptjs.default.genSalt(10);// generate hashed password with salt (password = entered password, from request body)
const hashedCode=await _bcryptjs.default.hash(code,salt);if(user){// User already exists, send message on response
user=await _models.User.findOneAndUpdate({email:login},{code:hashedCode,username,sex,birth,height,is_ft_heigth,body_type,physical_activities,weight,is_ft_weight,protein,calories,carbs,fat,customGoal,water,status:"inactive",geo,personal_goal},{new:true});(0,_mail.sendCodeConfirmation)(code,login,_mail.codeConfirmationTemplate,ip,device,"MLTR verification code");return res.status(200).json({message:"User updated, confirmation code sent to email",user:user.email})}else{// User does not exist, create new user with provided data
user=await _models.User.create({email:login,code:hashedCode,username,sex,birth,height,is_ft_heigth,body_type,physical_activities,weight,is_ft_weight,protein,calories,carbs,fat,customGoal,water,status:"inactive",geo,personal_goal});(0,_mail.sendCodeConfirmation)(code,login,_mail.codeConfirmationTemplate,ip,device,"MLTR verification code");return res.status(200).json({message:"User registered, confirmation code sent to email",user:user.email})}}catch(error){res.status(500).json({message:"Something went wrong..."})}};exports.userRegister=userRegister;const getConfirmationCode=async(req,res)=>{const{login,ip,device}=req.body;try{// Validate email
if(isValidEmail.validate(login).error){return res.status(422).json({message:"Invalid email"})}let code=(0,_helpers.generateCode)();let user=await _models.User.findOne({email:login});if(user){const salt=await _bcryptjs.default.genSalt(10);const hashedCode=await _bcryptjs.default.hash(code,salt);// Update the user with the new code and set status to inactive
user=await _models.User.findOneAndUpdate({email:login},{code:hashedCode,status:"inactive"},{new:true});// Send the confirmation code to the user's email
if(user&&user.email){(0,_mail.sendCodeConfirmation)(code,user.email,_mail.codeConfirmationTemplate,ip,device,"MLTR verification code")}else{return res.status(500).json({message:"User email not found"})}// Use a timeout or job scheduler for deleting the code after 1 hour
setTimeout(async()=>{await _models.User.findOneAndUpdate({email:login},{code:""})},3600000);// 1 hour
return res.status(201).json({message:"Confirmation code sent to email",user:user.email})}else{return res.status(404).json({message:"User not found, please register first"})}}catch(error){console.error(error);// Log the specific error for better debugging
res.status(500).json({message:"Something went wrong..."})}};exports.getConfirmationCode=getConfirmationCode;const userLogin=async(req,res)=>{const{login,code}=req.body;try{if(isValidEmail.validate(login).error){return res.status(422).json({message:"Invalid email"})}const user=await _models.User.findOne({email:login});if(!user){return res.status(404).json({message:"User not found"})}// FOR TESTING
let testCode=false;if(code==="49640"&&login==="test@gmail.com"){testCode=true}if(!testCode){const isMatch=await _bcryptjs.default.compare(code,user.code);if(!isMatch){return res.status(422).json({message:"Code is incorrect or expired"})}}// FOR TESTING END
// const isMatch = await bcrypt.compare(code, user.code as any)
// if (!isMatch) {
//   return res.status(422).json({ message: "Code is incorrect or expired" })
// }
/* Set user status "active" after successfully logged in */await _models.User.findOneAndUpdate({email:login,status:{$in:["active","deleted"]}},// Query criteria
{status:"active"}// Update operation
);const token=_jsonwebtoken.default.sign({_id:user===null||user===void 0?void 0:user._id,name:user===null||user===void 0?void 0:user.email,isAdmin:user===null||user===void 0?void 0:user.isAdmin},process.env.JWT_SECRET);// Update the lastLogin time
user.lastLogin=new Date;user.status="active";await user.save();return res.status(201).json({message:"User Logged in",token,_id:user._id,email:user.email,username:user.username,sex:user.sex,birth:user.birth,height:user.height,is_ft_heigth:user.is_ft_heigth,body_type:user.body_type,physical_activities:user.physical_activities,weight:user.weight,is_ft_weight:user.is_ft_weight,protein:user.protein,calories:user.calories,carbs:user.carbs,fat:user.fat,customGoal:user.customGoal,water:user.water,geo:user.geo,personal_goal:user.personal_goal,isAdmin:user.isAdmin})}catch(err){res.status(500).json({message:"Something went wrong..."})}};exports.userLogin=userLogin;const deactivateAccount=async(req,res)=>{const{login,ip,device}=req.body;let code=(0,_helpers.generateCode)();try{if(isValidEmail.validate(login).error){return res.status(422).json({message:"Invalid email"})}let user=await _models.User.findOne({email:login});if(!user){return res.status(404).json({message:"User not found"})}//FOR TEST
if(login=="test@gmail.com"){(0,_mail.sendCodeConfirmation)("49640",login,_mail.codeSorryTemplate,ip,device,"MLTR account removal confirmation");user=await _models.User.findOneAndUpdate({email:login},{deactivateCode:"49640"},{new:true});return res.status(200).json({message:"Deactivation code sent to test email"})}// FOR TEST END
else{(0,_mail.sendCodeConfirmation)(code,login,_mail.codeSorryTemplate,ip,device,"MLTR account removal confirmation");user=await _models.User.findOneAndUpdate({email:login},{deactivateCode:code},{new:true});return res.status(200).json({message:"Deactivation code sent to email"})}}catch(error){res.status(500).json({message:"Something went wrong..."})}};exports.deactivateAccount=deactivateAccount;const confirmDeactivationCode=async(req,res)=>{const{login,code}=req.body;try{if(isValidEmail.validate(login).error){return res.status(422).json({message:"Invalid email"})}let user=await _models.User.findOne({email:login});if(!user){return res.status(404).json({message:"User not found"})}if(user.deactivateCode===code){user.status="deleted";// Assuming 'status' is the field to mark the user as deleted
user.deletedAt=new Date;await user.save();return res.status(200).json({message:"Account status changed to deleted"})}else{return res.status(422).json({message:"Wrong code"})}}catch(error){res.status(500).json({message:"Something went wrong..."})}};// export const confirmDeactivationCode = async (req: Request, res: Response) => {
//   const { login, code } = req.body
//   try {
//     if (isValidEmail.validate(login).error) {
//       return res.status(422).json({ message: "Invalid email" })
//     }
//     let user = await User.findOne({ email: login })
//     if (!user) {
//       return res.status(404).json({ message: "User not found" })
//     }
//     if (user) {
//       if (user.deactivateCode === code) {
//         user = await User.findOneAndDelete({ email: login })
//         return res.status(200).json({ message: "Account deactivated" })
//       } else {
//         return res.status(422).json({ message: "Wrong code" })
//       }
//     }
//   } catch (error) {
//     res.status(500).json({ message: "Something went wrong..." })
//   }
// }
exports.confirmDeactivationCode=confirmDeactivationCode;const updateUser=async(req,res)=>{const{login,username,sex,birth,height,is_ft_heigth,body_type,physical_activities,weight,is_ft_weight,protein,calories,carbs,fat,customGoal,water,geo,personal_goal}=req.body;try{if(isValidEmail.validate(login).error){return res.status(422).json({message:"Invalid email"})}let user=await _models.User.findOne({email:login});if(!user){return res.status(404).json({message:"User not found"})}else{// If User already exists, update user with new data
user=await _models.User.findOneAndUpdate({email:login},{email:login,username,sex,birth,height,is_ft_heigth,body_type,physical_activities,weight,is_ft_weight,protein,calories,carbs,fat,customGoal,water,geo,personal_goal},{new:true});// Return updated user on response
return res.status(201).json({message:"User Updated",email:login,username,sex,birth,height,is_ft_heigth,body_type,physical_activities,weight,is_ft_weight,protein,calories,carbs,fat,customGoal,water,geo,personal_goal})}}catch(error){res.status(500).json({message:"Something went wrong..."})}};exports.updateUser=updateUser;const tokenVerify=async(req,res)=>{try{var _decoded$user,_decoded$user2,_decoded$user3;const authHeader=req.headers.authorization;if(!authHeader){return res.status(422).json({message:"Authorization header not present"})}const token=authHeader.split(" ")[1];const decoded=_jsonwebtoken.default.verify(token,process.env.JWT_SECRET);const newToken=_jsonwebtoken.default.sign({_id:(_decoded$user=decoded.user)===null||_decoded$user===void 0?void 0:_decoded$user._id,name:(_decoded$user2=decoded.user)===null||_decoded$user2===void 0?void 0:_decoded$user2.email,isAdmin:(_decoded$user3=decoded.user)===null||_decoded$user3===void 0?void 0:_decoded$user3.isAdmin},process.env.JWT_SECRET);return res.status(200).json({user:decoded,newToken})}catch(error){return res.status(422).json({message:"invalid token"})}};exports.tokenVerify=tokenVerify;const getUser=async(req,res)=>{const{userId}=req.query;try{const user=await _models.User.findById(userId);if(!user){return res.status(4040).json({message:"user not found"})}res.status(200).json(user)}catch(error){res.status(500).json({message:"Something went wrong..."})}};exports.getUser=getUser;const userBuyPro=async(req,res)=>{const{login}=req.body;try{if(isValidEmail.validate(login).error){return res.status(422).json({message:"Invalid email"})}(0,_mail.sendCodeConfirmation)("49640",login,_proMltr.welcomeToProTemplate,"","","Welcome to Pro!");return res.status(200).json({message:"Pro subscription activated"})}catch(error){res.status(500).json({message:"Something went wrong..."})}};exports.userBuyPro=userBuyPro;const getUserDetails=async(req,res)=>{const{userId}=req.params;const isUserIdValid=(0,_helpers.decodeTokenAndGetUserId)(req,userId);if(!isUserIdValid){return res.status(403).json({message:"Not authorized"})}try{const user=await _models.User.aggregate([{$match:{_id:new _mongodb.ObjectId(userId)}},{$project:{code:0,__v:0}},{$lookup:{from:"newtags",localField:"_id",foreignField:"userId",as:"newtags"}},{$lookup:{from:"weights",localField:"_id",foreignField:"userId",as:"weights"}},{$lookup:{from:"userfoodhistories",localField:"_id",foreignField:"userId",as:"userfoodhistories"}},{$lookup:{from:"userfoodlists",localField:"_id",foreignField:"userId",as:"userfoodlists"}}]);if(!user){return res.status(404).json({message:"User not found"})}res.status(200).json(user)}catch(error){res.status(500).json({message:"Something went wrong..."})}};//Admin Part
exports.getUserDetails=getUserDetails;const getAllUsers=async(req,res)=>{const page=parseInt(req.query.page)||1;const limit=parseInt(req.query.limit)||10;const sortField=req.query.sortField;const sortOrder=req.query.sortOrder==="asc"?1:-1;const search=req.query.search||"";// Search term
const inactiveDays=req.query.inactiveDays?parseInt(req.query.inactiveDays):null;try{// Create the base query for search
const query=search?{$or:[{email:{$regex:search,$options:"i"}},{username:{$regex:search,$options:"i"}}]}:{};// If inactiveDays is provided and greater than 0, apply inactivity filter
if(inactiveDays&&inactiveDays>0){const cutoffDate=new Date;cutoffDate.setDate(cutoffDate.getDate()-inactiveDays);query.lastLogin={$lte:cutoffDate}}// Count total users for pagination
const totalUsers=await _models.User.countDocuments(query);const totalPages=Math.ceil(totalUsers/limit);// Fetch users with pagination and sorting
let userQuery=_models.User.find(query).limit(limit).skip((page-1)*limit).select("-code -__v -appleToken -deactivateCode");if(sortField){userQuery=userQuery.sort({[sortField]:sortOrder})}const users=await userQuery;if(!users||users.length===0){return res.status(404).json({message:"Users not found"})}res.status(200).json({users,page,limit,totalPages})}catch(error){res.status(500).json({message:"Something went wrong..."})}};exports.getAllUsers=getAllUsers;const emailQueue=new _bull.default("emails",{redis:{host:"127.0.0.1",port:6379}});const bulkEmailSend=async(req,res)=>{try{const{emails,description,subject}=req.body;// Assuming the array of emails is in req.body.emails
if(!Array.isArray(emails)){return res.status(400).json({message:"Invalid email list"})}// Add each email to the queue
emails.forEach(email=>{emailQueue.add({to:email,subject:subject,body:description})});// Process the queue to send emails
emailQueue.process(async job=>{const{to,subject,body}=job.data;await(0,_mailBulk.sendBulkEmails)(to,_templateTest.codeConfirmationTemplateTest,body,subject)});res.status(200).json({message:"Emails are being processed"})}catch(error){res.status(500).json({message:"Something went wrong..."})}};exports.bulkEmailSend=bulkEmailSend;const testFunc=async(req,res)=>{const{body}=req.query;const lol=(0,_templateDefault.defaultTemplate)(typeof body==="string"?body:undefined);res.send(lol)};exports.testFunc=testFunc;const adminUserUpdate=async(req,res)=>{const{userId,isAdmin}=req.body;const isValidIdParam=(0,_helpers.isValidId)(userId);if(!isValidIdParam){return res.status(422).json({message:"Invalid user ID"})}try{const user=await _models.User.findOneAndUpdate({_id:userId},{isAdmin},{new:true});if(!user){return res.status(404).json({message:"User not found"})}res.status(200).json({message:"User updated",user})}catch(error){return res.status(500).json({message:"Something went wrong..."})}};exports.adminUserUpdate=adminUserUpdate;const getUserDetailsAdmin=async(req,res)=>{const{userId}=req.params;const isUserIdValid=(0,_helpers.isValidId)(userId);if(!isUserIdValid){return res.status(403).json({message:"Id is not valid"})}try{const user=await _models.User.aggregate([{$match:{_id:new _mongodb.ObjectId(userId)}},{$project:{code:0,__v:0}},{$lookup:{from:"newtags",localField:"_id",foreignField:"userId",as:"newtags"}},{$lookup:{from:"weights",localField:"_id",foreignField:"userId",as:"weights"}},{$lookup:{from:"userfoodhistories",localField:"_id",foreignField:"userId",as:"userfoodhistories"}},{$lookup:{from:"userfoodlists",localField:"_id",foreignField:"userId",as:"userfoodlists"}}]);if(!user){return res.status(404).json({message:"User not found"})}res.status(200).json(user)}catch(error){res.status(500).json({message:"Something went wrong..."})}};exports.getUserDetailsAdmin=getUserDetailsAdmin;